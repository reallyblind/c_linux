				c语言学习笔记
c语言特点：
	1、基础性语言
	2、语法简介，紧凑，方便，灵活
	3、运算符，数据结构丰富
	4、结构化，模块化编程
	5、移植性好，执行效率高
	6、允许直接对硬件操作

c语言学习建议：
	1、概念的正确性
	2、动手能力
	3、阅读优秀的程序段
	4、大量练习，面试题
	

c语言讲解思路：
	1、基本概念
	2、数据类型，运算符和表达式
	3、输入输出专题
	4、流程控制
	5、数组
	6、指针
	7、函数
	8、构造类型
	9、动态内存管理
	10、调试工具和调试技巧（gdb，make）
	11、常用库函数

平台介绍：
	ubuntu,vim,gcc(make)


hello.c:
gcc：
C源文件 .c —— 预处理 —— 编译 —— 汇编 ——链接 ——可执行文件
gcc -E hello.c > hello.i
  407  ls
  408  gcc -S hello.i
  409  ls
  410  vim hello.s
  411  gcc -c hello.s
  412  ls
  413  gcc hello.o -o hello
  414  ls
  415  ./hello

编译器vim：
Vim配置脚本以及常用快捷方式












		

	  			一、基本概念
1、以helloworld为例对写程序的思路提出如下要求：
	c语言中没有看到函数原型默认返回值为int，所以malloc没有头文件要强转	
	1) 头文件正确包含的重要性
	2）以函数为单位进行程序编写
	3）声明部分 + 实现部分
	4）return 0;  没写的话返回值为printf的返回值，返回给当前的环境，目前环境为shall
	5）多用空格空行
	6）多加注释


2、算法：解决问题的方法（流程图、NS图，有限状态机FSM）
3、程序：用某种语言实现算法
4、进程：
5、防止写越界，防止内存泄漏，谁打开谁关闭，谁申请谁释放







				二、数据类型，运算符和表达式
1、数据类型（基本数据类型）
	参考图片基本数据类型 	嵌入式不支持最新标准所以不支持二进制赋值
	1）所占字节数：数据类型所占字节数随硬件不同不同，标准c只规定了int类型占一个机器字长，其他以int为基准。

	2）存储区别：
		254 -> unsigned int -> 32位
		-254 ->254 ->1111 1110 取反 +1

		(254)10 = (11111110)2 = (00000000 0000000 00000000 11111110)2 = (376)8
		=(FE)16
		254
		B11111110
		0376
		0XFE

		float为例: 0-22位 小数部分 23-30位指数部分 31位符号位
		3.14
		0.314 * 10
		0.0314 * 10^2
		314 * 10^-2

		0.000789 -> 0.789 * 10 ^-3
		double精度更高


		字符型
		char有无符号在标准c语言中没有定义。char ch;不一定有符号

	3）不同类型的数据间类型转换（隐式，显式->强制类型转换）：
		int i;
		float f;
		double d;
		char ch;
		隐式转换
		ch + i -> i
		f - d  -> d
		(ch + i ) - ( float - double )
		  int     -    double
			double


	4）特殊性：
		(1) 布尔型bool
		(2) float类型
			|f - 0| <= 10^-6 可认为0
			fabs(f - 0) <= 1e-6
		(3) char型是否有符号
			未定义
		(4) 不同形式的0值
			'0' "0" '\0' NULL




2、变量与常量
常量：在程序执行过程中值不会发生变化的值，不能被赋值，不能出现在赋值的左边
	1 = f ; //error
	float f = 3.14 ;  3.14是常量


	分类：整型常量，实型常量，字符常量，字符串常量，标识常量
		整型常量： 1,790 ，76
		实型常量： 3.14, 5.26 ，1.999
		字符常量：由单引号引起来的单个字符或转移字符 'a' '\n' 
			'\015' , '\x7f' ,      '\018'错,8进制不能写8
		字符串常量:由双引号引起来的一个或多个字符组成的序列(空串) 
			如:"" , "a" , "abc\n\021\018" -> abc \n \021 \0 18
			不是基本类型
		标识常量: #define  处理在程序的预处理阶段，占编译时间，一改全该
				缺点：不检查语法，只是单纯的宏体与宏名之间的替换。
			
			稳定用函数，速度用宏	
			
			例子：#define ADD 2+3 -> ADD*ADD -> 2+3*2+3 = 11
			     #define MAX(a,b) ((a)>(b)?(a):(b))  MAX(1,2)
			    printf(MAX(i++),(j++));会自增两次各自加2
				( (i++) > (j++) ) ? (i++) : (j++) );
			已经出错，标准c无解
			
			GNU C可解
			#define MAX(a,b) \
				({typeof(a) A = a,B =b; ((A)>(B) ? (A) :(B));})
			


变量：用来保存一些特定内容，并且在程序执行过程中值会随时变化的量
定义：[存储类型] 数据类型 标识符 = 值
		TYPE NAME = VALUE;
	标识符：由字母，数字，下划线组成且不能以数字开头的一个标识序列。
		写标识符尽量做到见名生义
	数据类型：基本数据类型 + 构造类型
	值 ： 注意匹配
	存储类型：auto  static  register （定义型）  extern（说明型）
		auto：默认，自动分配内存，自动回收内存
		register：（建议型关键字）寄存器类型，只能定义局部变量，不能定义全局变量;大小有限制，只能定义32位大小的数据类型，如double就不可以，寄存器没有地址，所以一个寄存器类型的变量无法打印出地址查看或使用
		static：静态型，自动初始化为 0值或空值，并此类型的变量的值有继承性,全局变量最好加上static以保证只在本文件中使用
		extern：说明型，意味着不能改变被说明的变量的值或类型
			extern定义变量的时候只能是声明,也就是说，只能是extern int a;来声明有一个外部整形变量a.不能写extern int a=1;来给外部整形变量a幅初值1.编译会报错的。 只能声明，表示使用外部的同名变量，不能赋值
		


		int i = 1; auto型
		register int i = 1; register型，建议放到register，由gcc来判断是否放到register上


	变量的生命周期和作用范围：
		1）全局变量和局部变量
			全局变量：进程生成生成，进程结束销毁
			局部变量：代码块调用结束就销毁
		2）局部变量和局部变量
			就近原则
		3）参考图片:变量存储类型.png

		
	全局变量慎用,一般用static表示只在本文件使用


3、运算符和表达式

表达式与语句的区别

运算符部分：
	1）每个运算符所需要的参与运算的操作数个数
	2）结合型
	3）优先级
	4）位运算的特殊用法
	5）位运算的重要意义
		将操作数中某一位置1，其他位不变：num = num | 1<<n;
		将操作数中某一位置0，其他位不变：num = num & ~(1<<n);
		测试第n位： if(num & 1<<n )
		从一个指定宽度的数中取出某几位：
(num & (((1 << (n_bit - m_bit + 1)) - 1) << (m_bit - 1))) >> (m_bit - 1)

算数运算符：+ - * / % ++ --
5 / 2 = 2;
5 % 2 = 1;
5.0/2 = 2.5;
5.0%2 ; error 得是整数

运算符在前，先进行计算，再取变量值使用
变量在前，先去变量值使用，再进行计算
int i = 1;
i++; -->表达式值为1 ，i值为2
++i; -->表达式值为2 ，i值为2

int i =1,j=10,value;
value = i++ + ++j ; // i++取1 ，++j取11 ，原式相当于 value = 1 + 11;

value = --i + j++; //--i取0,j++取10,得10

关系运算符： < >= <= == > <= !=

逻辑运算符 ：! && ||
&& || 的短路运算性
位运算符：<< >> ~ | ^ &

赋值运算符：=及其拓展

条件运算符：

逗号运算符：取最后一个值

指针运算符： *

求字节数 ： sizeof

强制类型转换：（类型）

分量运算符：.  ->

下表运算符：[]

其他： ()





				三、输入、输出专题
input & output -> I/O(标准IO，文件IO)

1、格式化输入输出函数：scanf，printf
	int printf(const char *format, ...);
	format："%[修饰符]格式字符",参照图片标准输出修饰符，输入输出格式字符
	char型可以看做短整型，由于太小一般不作为函数传参
	
	int scanf(const char *format, ...);
	scanf放到循环中很危险，一旦输入和格式不匹配会出现下次循环还直接取错误值，因为没有刷新缓冲区，
	解决方法：scanf返回值负表示没有接受到，接受几个值返回几，可加一个if来避免出错
	format：抑制符*	
	%s的使用是比较危险的，因为不知道存储空间大小
	scanf放在循环结构中要注意能否接收到正常有效的内容

2、字符输入输出函数：getchar，putchar
3、字符串输入输出函数：gets(危险!)，puts
	gets：十分危险的函数，never use





				四、流程控制
顺序，选择，循环
NS图， 流程图     工具Dia
简单结构和复杂结构：自然流程 ：








				五、数组
一维数组					构造类型之一，连续存放
数组名是表示地址的常量，不能放在等号的左边	
	1、定义
		[存储类型] 数据类型 标识符 [下标] ;
			char ch[5];
	2、初始化
		不初始化 
		全初始化
		部分初始化 赋值的为值，没有的为0
		static 默认赋值为0
	3、元素引用
		数组名[下标]
	4、数组名
		数组名是表示地址的常量，也是数组的起始位置
	5、数组越界
		数组越界是不报错的，需要细心
		a[i] = *(a+i)

		


二位数组		内存中占用空间是连续的，00 01 02 10 11 12
	1、定义，初始化
		[存储类型] 数据类型 标识符[行下标][列下标];
	2、元素引用
		数组名[行标][列标]
	3、存储形式
		顺序存储，按行存储
	4、深入理解二维数组
	a[2][3]  a+1跳过一行得到a[1]即第二行

字符数组
	1、定义，初始化，存储特点
		[存储类型]数据类型 标识符[下标] ...
		单个字符初始化
		字符串常量初始化
		字符串末尾带'\0'
	2、输入输出
		scanf,printf,fgets,gets,puts
		%s无法获取带空格的字符串
	3、常用函数
		strlen & sizeof
		strcpy & strncpy
		strcat & strncat
		strcmp & strncmp



多维数组
	1、




				六、指针
printf("%ld\n",sizeof(p));//8   64位是8,32位是4,指针在一个平台上统
一的

1、变量与地址
	指针就是地址，
2、指针与指针变量
	指针类型和变量类型匹配，因为指针要向后对取对应类型的字节数
3、直接访问与间接访问
	i  *p=&i  **q=&p  初始化 ||     **q=*p=i    &i=p=*q 
4、空指针与野指针
	定义时直接置为NULL
5、空类型
	void *q; 百搭指针，任意类型的值都可赋值到他上边，他也可以赋到任何类型的指针
	memcpy(void *memcpy(void *dest, const void *src, size_t n);
	
	void*  和一个指针函数之间来互相赋值，只有这种情况c99无定义，其他均可用
	void* 赋给任何类型都天经地义
6、定义与初始化的书写规则
	int i=1;
	int *p = &i;
	int **q = &p;
7、指针运算
	&  *  关系运算 ++ --

8、指针与数组
	指针与一维数组
		int a[]={1,2,3}; a++//error
		int *p = a;  p++//right 
		a数组名是表示地址的常量，p表示地址的变量
	指针与二维数组
		int a[2][3];  int *p;  p=a;//warning
		等号右边是一个地址常量，表示的是一个可以在行间移动的指针
		p是在列上移动的	
		p = *a;  p[i]可遍历a的全部元素	

	指针与字符数组
		
9、const与指针
	指针常量   
	常量指针

10、指针数组与数组指针
	数组指针：	[存储类型]  数据类型  (*指针名)[下标] = 值
		int a[2][3];  int (*q)[3] = a;  a和q的值一样，a+1和q+1也一样
		如 ： int (*p)[3] ; --->  type name; ---> int [3] *p;  p+1一下移动3个
	指针数组：	[存储类型] 数据类型 *数组名[长度]
		如: int *arr[3]  -> TYPE NAME; int *[3]   arr;
		存着指针的数组
		char *arr[5] = {"Hello","world","nihao","le","hl"};	
	
		char *                    arr          [5]
		每个数组类型char*    数组名	     数组的数量
11、多级指针
	见图片：多级指针.png




					七、函数
1、函数定义
	数据类型  函数名([形式参数说明表])
	数据类型  函数名(数据类型 参数名，数据类型 参数名，数据类型 参数名，......)
2.函数的传参
	值传递
	地址传递
	全局变量

3、函数的调用
	嵌套调用
	递归调用
		1)调用条件 2)已知条件做退出条件 3)条件是否成立，检错条件
4、函数与数组
	函数和一维数组
	/*
	*int a[N] = {1,2,3,4,5,6};
	*int *p = a;
	*想传的参数：
	*->a   	        *a	  a[0]      &a[3]     p[i]     p        *p        p+1
	*		*(a+0)
	*传的数据类型
	*->int*		int	  int 	    int*       int     int*      int    int*
	*
	*/
	
	函数和二维数组
/*
*	  传参值
*->     a[i][j]         *(a+i)+j        a[i]+j          p[i]            *p
*       q[i][j]         *q              q               p+3             q+2
*                       *(q+0)
*  	 应当接收的类型
*->     int             int *           int *           int             int
*       int             int *           int(*) [N]      int*            int(*) [N]      
*/	
	
5、函数与指针
	指针函数       返回值为函数
		返回值 * 函数名 (形参);
		如： int * fun(int);

	函数指针	指针指向的是函数
		类型 (*指针名) (新参)
		如：int (*p) (int);
	函数指针数组
		类型 (*数组名[下标]) (形参)
		如：int (*arr[N])(int);



				八、结构体及union
结构体
1、产生及意义
2、类型描述
	struct 结构体名
	{
		数据类型 成员1;
		数据类型 成员2;
		......
	}

3、嵌套定义
4、定义变量（变量，数组，指针），初始化及成员引用
	成员引用：变量名.成员名
		  指针->成员名
		  (*指针).成员名
5、占用内存空间大小
6、函数传参（值，地址）
	传值是深拷贝，开销较大，推荐传地址


union
1、产生及意义
2、类型描述
	union 共用体名
	{
		数据类型 成员名1;
		数据类型 成员名2;
		......
	};
3、嵌套定义
	
4、定义变量（变量，数组，指针），初始化及成员引用
5、占用内存空间大小
6、函数传参（值，地址）

7、位域
	见Documents/c_linux/stuct_union/union2.c
	见图片union位域.png



枚举enum
enum 标识符
{
	成员1 (= 1);
	成员2;
	.....
};




			

				九、动态内存管理
malloc ralloc realloc free
原则：谁申请谁释放

见  Documents/c_linux/malloc_free$ vim malloc.c


typedef:为已有的数据类型改名
	typedef 已有的数据类型 新名字;
#define INT int
typedef int INT;

INT i;    ->    int i;

#define IP int *
typedef int *IP;

IP p,q; ->      int *p,q;
IP p,q; ->      int *p,*q;

#define INT int
typedef int INT;

INT i;    ->    int i;


#define IP int *
typedef int *IP;

IP p,q; ->      int *p,q;
IP p,q; ->      int *p,*q;


typedef int ARR[6];     ->      int[6]  ->  ARR;
ARR a;  ->      int a[6];

struct node_st
{
        int i;
        float f;
};
typedef struct node_st NODE;
NODE a;         ->      struct node_st a;

typedef struct node_st *NODEP;
NODEP p;        ->      struct node_st *p;

typedef struct
{
        int i;
        float f;
}NODE *NODEP;

typedef int FUNC(int);  ->int (int) FUNC;
FUNC f; --> int f(int);

typedef int *FUNCP(int);

FUNCP p; --> int *p(int);


typedef int * (*FUNCP)(int)
FUNCP p; -->  int *(*p) (int);




makefile:
	gcc *.c  ---->  a.out
	a.out -->  main.o  tool1.o  tool2.o
	main.o  -->  main.c
	tool1.o -->  tool.c
	tool2.o -->  tool2.c




					静态库
libxx.a
xx指代库名

ar -cr libxx.a yyy.o

发布到
/usr/local/include
/usr/local/lib

gcc -L/usr/local/lib -o main main.o -lxx
-l参数必须在最后，有依赖











































